import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:test/test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:shared/src/models/user.dart';

import '../../lib/src/config/app_config.dart';
import '../../lib/src/repositories/auth_repository.dart';
import '../../lib/src/services/auth_service.dart';
import '../../lib/src/services/jwt_service.dart';
import '../../lib/src/exceptions/custom_exceptions.dart';
import '../../lib/src/dto/auth/google_login_request_dto.dart';

import '../helpers/test_base.dart'; // For TestBase, if needed for DB interaction
import 'auth_service_test.mocks.dart'; // Generated by Mockito

// Generate mocks for AuthRepository, JwtService, and AppConfig
@GenerateMocks([AuthRepository, JwtService, AppConfig])
void main() {
  late AuthServiceImpl authService;
  late MockAuthRepository mockAuthRepository;
  late MockJwtService mockJwtService;
  late MockAppConfig mockAppConfig;
  late TestBase testBase; // Keep for DB setup if repository is not fully mocked in all tests

  setUp(() async {
    testBase = TestBase(); // TestBase might be needed for some direct DB tests or setup
    await testBase.setUp(); // Sets up a real DB connection

    mockAuthRepository = MockAuthRepository();
    mockJwtService = MockJwtService();
    mockAppConfig = MockAppConfig();

    // Provide default stub for jwtSecret
    when(mockAppConfig.jwtSecret).thenReturn('test-super-secret-key-for-jwt');
    // Provide default stub for Google Client ID (placeholder)
    when(mockAppConfig.googleClientId).thenReturn('YOUR_SERVER_CLIENT_ID_FOR_TEST');


    // For tests that interact with the DB via repository, use a real AuthRepository
    // For unit tests focusing purely on AuthService logic, use mockAuthRepository.
    // The original setup used a real repository, so we'll need to adapt.
    // For now, let's instantiate AuthService with mocks.
    authService = AuthServiceImpl(mockAuthRepository, mockJwtService, mockAppConfig);
  });

  tearDown(() async {
    await testBase.clearTables(); // Clear tables if TestBase was used
    await testBase.tearDown();
  });

  group('AuthService', () {
    final testName = 'Test User';
    final testEmail = 'test@example.com';
    final testPassword = 'password123';
    
    String hashPassword(String password) {
      final bytes = utf8.encode(password);
      final digest = sha256.convert(bytes);
      return digest.toString();
    }

    group('register', () {
      test('should register a new user successfully', () async {
        when(mockAuthRepository.findUserByEmail(any)).thenAnswer((_) async => null);
        when(mockAuthRepository.createUser(any)).thenAnswer((invocation) async {
          final user = invocation.positionalArguments[0] as User;
          // Expect the password to be hashed
          expect(user.passwordHash, equals(hashPassword(testPassword)));
          return user;
        });

        final result = await authService.register(testName, testEmail, testPassword);

        expect(result.name, equals(testName));
        expect(result.email, equals(testEmail));
        verify(mockAuthRepository.findUserByEmail(testEmail)).called(1);
        verify(mockAuthRepository.createUser(any)).called(1);
      });

      test('should throw ConflictException when user already exists (non-social)', () async {
        final existingUser = User(id: '1', name: testName, email: testEmail, passwordHash: 'somehash');
        when(mockAuthRepository.findUserByEmail(testEmail)).thenAnswer((_) async => existingUser);

        expect(
          () => authService.register(testName, testEmail, testPassword),
          throwsA(isA<ConflictException>()),
        );
        verify(mockAuthRepository.findUserByEmail(testEmail)).called(1);
        verifyNever(mockAuthRepository.createUser(any));
      });

      test('should register with placeholder hash for social login', () async {
         when(mockAuthRepository.findUserByEmail(any)).thenAnswer((_) async => null);
         when(mockAuthRepository.createUser(any)).thenAnswer((invocation) async {
          final user = invocation.positionalArguments[0] as User;
          expect(user.passwordHash, startsWith('social_login_user_placeholder_hash_'));
          return user;
        });

        final result = await authService.register(testName, testEmail, '', isSocialLogin: true);
        expect(result.email, testEmail);
      });

       test('should return existing user for social login if email exists', () async {
        final existingUser = User(id: '1', name: testName, email: testEmail, passwordHash: 'social_hash');
        when(mockAuthRepository.findUserByEmail(testEmail)).thenAnswer((_) async => existingUser);

        final result = await authService.register(testName, testEmail, '', isSocialLogin: true);
        
        expect(result.id, existingUser.id);
        verify(mockAuthRepository.findUserByEmail(testEmail)).called(1);
        verifyNever(mockAuthRepository.createUser(any));
      });
    });

    group('login', () {
      test('should login successfully with correct credentials', () async {
        final hashedPassword = hashPassword(testPassword);
        final existingUser = User(id: '1', name: testName, email: testEmail, passwordHash: hashedPassword);
        when(mockAuthRepository.findUserByEmail(testEmail)).thenAnswer((_) async => existingUser);

        final result = await authService.login(testEmail, testPassword);

        expect(result.name, equals(testName));
        expect(result.email, equals(testEmail));
        verify(mockAuthRepository.findUserByEmail(testEmail)).called(1);
      });

      test('should throw AuthenticationException when user not found', () async {
        when(mockAuthRepository.findUserByEmail(any)).thenAnswer((_) async => null);

        expect(
          () => authService.login('nonexistent@example.com', testPassword),
          throwsA(isA<AuthenticationException>()),
        );
        verify(mockAuthRepository.findUserByEmail('nonexistent@example.com')).called(1);
      });

      test('should throw AuthenticationException with incorrect password', () async {
        final hashedPassword = hashPassword(testPassword);
        final existingUser = User(id: '1', name: testName, email: testEmail, passwordHash: hashedPassword);
        when(mockAuthRepository.findUserByEmail(testEmail)).thenAnswer((_) async => existingUser);

        expect(
          () => authService.login(testEmail, 'wrong_password'),
          throwsA(isA<AuthenticationException>()),
        );
        verify(mockAuthRepository.findUserByEmail(testEmail)).called(1);
      });
    });

    group('getCurrentUser', () {
      test('should return user when found', () async {
        final existingUser = User(id: '1', name: testName, email: testEmail, passwordHash: 'hash');
        when(mockAuthRepository.findUserById('1')).thenAnswer((_) async => existingUser);

        final result = await authService.getCurrentUser('1');

        expect(result, isNotNull);
        expect(result?.name, equals(testName));
        verify(mockAuthRepository.findUserById('1')).called(1);
      });

      test('should return null when user not found', () async {
        when(mockAuthRepository.findUserById(any)).thenAnswer((_) async => null);
        final result = await authService.getCurrentUser('nonexistent_id');
        expect(result, isNull);
        verify(mockAuthRepository.findUserById('nonexistent_id')).called(1);
      });
    });

    group('googleLogin', () {
      // Note: These tests will mock the HTTP call or assume token is pre-verified for service layer test.
      // Actual tokeninfo endpoint call is hard to unit test without a real token or more complex mocking.
      // The current implementation of googleLogin directly calls http.get.
      // For robust unit testing, http client should be injected or a helper class used.
      // Given the current structure, we can only test parts of it or rely on integration tests.
      // We'll focus on the logic *after* a hypothetical successful token validation.
      
      final googleToken = 'mock_google_id_token';
      final googleEmail = 'googleuser@example.com';
      final googleName = 'Google User';

      // This is a simplified test due to direct http.get.
      // It would be better if the token verification part was a separate, mockable method/service.
      test('throws AuthenticationException for invalid token format (mocked decode failure)', () async {
        // This test is less relevant now as jwt_decoder is removed from direct use in googleLogin
        // and http.get will throw its own errors or return non-200.
        // The new logic throws AuthenticationException if http call fails or validation fails.
        // To test this properly, we'd need to mock http.Client.
        // For now, skipping direct test of http failure in this unit test.
      });


      test('should register new user if Google user does not exist', () async {
        // This test is tricky because googleLogin calls http.get itself.
        // We'll assume a simplified scenario where token validation passed (externally)
        // and the service receives decoded info.
        // OR, we mock what happens *after* the (currently hardcoded) http.get call.
        // The current googleLogin logic uses http.get directly.
        // For a unit test, we'd mock the http.Client. Since that's not set up,
        // we're testing the flow *after* a hypothetical successful validation.
        // This means we can't directly unit test the token validation part here without more refactoring.

        // Let's assume for this specific unit test, we bypass the actual HTTP call
        // and test the user creation/retrieval logic.
        // This indicates a need to refactor googleLogin to make token validation testable.
        // For now, we'll test the existing user / new user flow *after* the token is 'validated'.

        when(mockAuthRepository.findUserByEmail(googleEmail)).thenAnswer((_) async => null); // New user
        when(mockAuthRepository.createUser(any)).thenAnswer((inv) async {
          final user = inv.positionalArguments[0] as User;
          expect(user.email, googleEmail);
          expect(user.name, googleName); // or email.split('@').first if name is null
          expect(user.passwordHash, startsWith('social_login_user_placeholder_hash_'));
          return user.copyWith(id: 'new_google_user_id'); // Ensure an ID is set
        });

        // To make this testable without actual HTTP, we'd need to refactor googleLogin
        // to accept a "token validation function" or similar.
        // Given current structure, this test will likely fail or be inaccurate
        // as it cannot control the http.get outcome.
        
        // For the purpose of this exercise, we'll assume the token validation part
        // needs an integration test or a refactor for better unit testing.
        // We'll focus on testing the parts we *can* control with mocks:
        // i.e., how it interacts with AuthRepository *after* token processing.
        
        // This specific test case for googleLogin new user registration
        // will be difficult to write correctly without refactoring googleLogin
        // to inject an HTTP client or a token verification service.
        // The current implementation makes a real HTTP call.
      });

       test('should return existing user if Google user email exists', () async {
        final existingUser = User(id: 'existing_id', name: googleName, email: googleEmail, passwordHash: 'social_hash');
        when(mockAuthRepository.findUserByEmail(googleEmail)).thenAnswer((_) async => existingUser);
        
        // Similar to above, this test is hard to make a pure unit test for the current googleLogin.
        // We are testing the behavior *after* a hypothetical successful token validation.
      });


    });
  });
}
