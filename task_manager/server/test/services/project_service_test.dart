import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:test/test.dart';
import 'package:shared/models.dart' as shared_models;

import '../../lib/src/repositories/project_repository.dart';
import '../../lib/src/services/project_service.dart';
import '../../lib/src/exceptions/custom_exceptions.dart';
import '../../lib/src/dto/user_public_response_dto.dart';

import 'project_service_test.mocks.dart'; // Generated by Mockito

@GenerateMocks([ProjectRepository])
void main() {
  late ProjectServiceImpl projectService;
  late MockProjectRepository mockProjectRepository;
  late String testUserId;
  late String otherUserId;

  setUp(() {
    mockProjectRepository = MockProjectRepository();
    projectService = ProjectServiceImpl(mockProjectRepository);
    testUserId = 'test_user_id_1';
    otherUserId = 'test_user_id_2';
  });

  group('ProjectService', () {
    final project1 = shared_models.Project(
      id: 'proj-1',
      name: 'Test Project 1',
      description: 'Description 1',
      creatorId: testUserId,
      memberIds: [testUserId],
    );
    final project2 = shared_models.Project(
      id: 'proj-2',
      name: 'Test Project 2',
      description: 'Description 2',
      creatorId: otherUserId,
      memberIds: [otherUserId, testUserId], // testUser is a member
    );
     final user1 = shared_models.User(id: testUserId, name: 'Test User 1', email: 'user1@example.com', passwordHash: 'hash1');
     final user2 = shared_models.User(id: otherUserId, name: 'Test User 2', email: 'user2@example.com', passwordHash: 'hash2');


    group('createProject', () {
      test('should create and return project', () async {
        when(mockProjectRepository.create(any)).thenAnswer((_) async => project1);
        final result = await projectService.createProject(project1);
        expect(result, project1);
        verify(mockProjectRepository.create(project1)).called(1);
      });
    });

    group('getProjectById', () {
      test('should return project if user is creator', () async {
        when(mockProjectRepository.findById(project1.id)).thenAnswer((_) async => project1);
        final result = await projectService.getProjectById(project1.id, testUserId);
        expect(result, project1);
      });

      test('should return project if user is member', () async {
        when(mockProjectRepository.findById(project2.id)).thenAnswer((_) async => project2);
        final result = await projectService.getProjectById(project2.id, testUserId); // testUser is member of project2
        expect(result, project2);
      });

      test('should return null if project not found', () async {
        when(mockProjectRepository.findById(any)).thenAnswer((_) async => null);
        final result = await projectService.getProjectById('non-existent', testUserId);
        expect(result, isNull);
      });

      test('should return null if user is not creator or member', () async {
        final projectNotAssociated = shared_models.Project(id: 'proj-3', name: 'Other', creatorId: 'another_creator', memberIds: ['another_creator']);
        when(mockProjectRepository.findById(projectNotAssociated.id)).thenAnswer((_) async => projectNotAssociated);
        final result = await projectService.getProjectById(projectNotAssociated.id, testUserId);
        expect(result, isNull);
      });
    });

    group('updateProject', () {
      test('should update project if user is creator', () async {
        when(mockProjectRepository.findById(project1.id)).thenAnswer((_) async => project1);
        when(mockProjectRepository.update(any)).thenAnswer((_) async => project1.copyWith(name: 'Updated'));
        
        final result = await projectService.updateProject(project1.id, project1.copyWith(name: 'Updated'), testUserId);
        expect(result.name, 'Updated');
        verify(mockProjectRepository.update(project1.copyWith(name: 'Updated'))).called(1);
      });

      test('should throw ProjectNotFoundException if project not found', () {
        when(mockProjectRepository.findById(any)).thenAnswer((_) async => null);
        expect(
          () => projectService.updateProject('non-existent', project1, testUserId),
          throwsA(isA<ProjectNotFoundException>()),
        );
      });

      test('should throw ForbiddenException if user is not creator', () {
        when(mockProjectRepository.findById(project2.id)).thenAnswer((_) async => project2); // project2 created by otherUserId
        expect(
          () => projectService.updateProject(project2.id, project2, testUserId), // testUserId tries to update
          throwsA(isA<ForbiddenException>()),
        );
      });
    });

    group('deleteProject', () {
      test('should delete project if user is creator', () async {
        when(mockProjectRepository.findById(project1.id)).thenAnswer((_) async => project1);
        when(mockProjectRepository.delete(project1.id)).thenAnswer((_) async => Future.value());
        
        await projectService.deleteProject(project1.id, testUserId);
        verify(mockProjectRepository.delete(project1.id)).called(1);
      });

       test('should throw ProjectNotFoundException if project not found for delete', () {
        when(mockProjectRepository.findById(any)).thenAnswer((_) async => null);
        expect(
          () => projectService.deleteProject('non-existent', testUserId),
          throwsA(isA<ProjectNotFoundException>()),
        );
      });

      test('should throw ForbiddenException if user is not creator for delete', () {
        when(mockProjectRepository.findById(project2.id)).thenAnswer((_) async => project2);
        expect(
          () => projectService.deleteProject(project2.id, testUserId),
          throwsA(isA<ForbiddenException>()),
        );
      });
    });

    group('getAllProjects', () {
      test('should call repository method with correct parameters', () async {
        when(mockProjectRepository.getAllProjects(any, any, any, any)).thenAnswer((_) async => []);
        await projectService.getAllProjects(testUserId, 1, 20, 'search');
        verify(mockProjectRepository.getAllProjects(testUserId, 1, 20, 'search')).called(1);
      });
    });

    group('getAllSystemProjects', () {
      test('should call repository method with correct parameters', () async {
        when(mockProjectRepository.getAllSystemProjects(any, any, any)).thenAnswer((_) async => []);
        await projectService.getAllSystemProjects(0, 15, 'query');
        verify(mockProjectRepository.getAllSystemProjects(0, 15, 'query')).called(1);
      });
    });

    group('assignUserToProject', () {
      test('should call repository method and return result', () async {
        final expectedResult = {'projectId': project1.id, 'userId': otherUserId};
        when(mockProjectRepository.assignUserToProject(project1.id, otherUserId))
            .thenAnswer((_) async => expectedResult);
        
        final result = await projectService.assignUserToProject(project1.id, otherUserId);
        expect(result, expectedResult);
        verify(mockProjectRepository.assignUserToProject(project1.id, otherUserId)).called(1);
      });
    });
    
    group('removeUserFromProject', () {
       test('should call repository method and return result', () async {
        when(mockProjectRepository.removeUserFromProject(project1.id, otherUserId))
            .thenAnswer((_) async => true);
        
        final result = await projectService.removeUserFromProject(project1.id, otherUserId);
        expect(result, isTrue);
        verify(mockProjectRepository.removeUserFromProject(project1.id, otherUserId)).called(1);
      });
    });

    group('getUsersByProject', () {
      test('should return list of UserPublicResponseDto', () async {
        when(mockProjectRepository.getUsersByProject(project1.id))
            .thenAnswer((_) async => [user1, user2]); // Repo returns List<User>
        
        final result = await projectService.getUsersByProject(project1.id);
        expect(result, isA<List<UserPublicResponseDto>>());
        expect(result.length, 2);
        expect(result.first.id, user1.id);
        expect(result.first.name, user1.name);
        expect(result.first.email, user1.email);
      });
    });

    group('getProjectsByUser', () {
       test('should call repository method and return result', () async {
        when(mockProjectRepository.getProjectsByUser(testUserId))
            .thenAnswer((_) async => [project1, project2]);
        
        final result = await projectService.getProjectsByUser(testUserId);
        expect(result, [project1, project2]);
        verify(mockProjectRepository.getProjectsByUser(testUserId)).called(1);
      });
    });

  });
}
