import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:test/test.dart';
import 'package:shared/models.dart' as shared_models;

import '../../lib/src/repositories/task_repository.dart';
import '../../lib/src/services/task_service.dart';
import '../../lib/src/exceptions/custom_exceptions.dart';

import 'task_service_test.mocks.dart'; // Generated by Mockito

@GenerateMocks([TaskRepository])
void main() {
  late TaskServiceImpl taskService;
  late MockTaskRepository mockTaskRepository;
  late String testUserId1;
  late String testUserId2;
  late DateTime testDueDate;

  setUp(() {
    mockTaskRepository = MockTaskRepository();
    taskService = TaskServiceImpl(mockTaskRepository);
    testUserId1 = 'test_user_id_1';
    testUserId2 = 'test_user_id_2';
    testDueDate = DateTime.utc(2025, 7, 15);
  });

  final task1 = shared_models.Task(
    id: 'task-1', title: 'Task 1', description: 'Desc 1', 
    status: shared_models.TaskStatus.todo, priority: shared_models.Priority.medium,
    creatorId: testUserId1, assigneeId: testUserId1, dueDate: testDueDate
  );
  final task2 = shared_models.Task(
    id: 'task-2', title: 'Task 2', description: 'Desc 2', 
    status: shared_models.TaskStatus.inProgress, priority: shared_models.Priority.high,
    creatorId: testUserId1, assigneeId: testUserId2, dueDate: testDueDate.add(Duration(days: 1))
  );

  group('TaskService', () {
    group('createTask', () {
      test('should create and return task', () async {
        when(mockTaskRepository.create(any)).thenAnswer((_) async => task1);
        final result = await taskService.createTask(task1);
        expect(result, task1);
        verify(mockTaskRepository.create(task1)).called(1);
      });
    });

    group('getTaskById', () {
      test('should return task if user is creator', () async {
        when(mockTaskRepository.findById(task1.id)).thenAnswer((_) async => task1);
        final result = await taskService.getTaskById(task1.id, testUserId1);
        expect(result, task1);
      });
      test('should return task if user is assignee', () async {
        when(mockTaskRepository.findById(task2.id)).thenAnswer((_) async => task2);
        final result = await taskService.getTaskById(task2.id, testUserId2);
        expect(result, task2);
      });
      test('should return null if task not found', () async {
        when(mockTaskRepository.findById(any)).thenAnswer((_) async => null);
        final result = await taskService.getTaskById('non-existent', testUserId1);
        expect(result, isNull);
      });
      test('should return null if user is not creator or assignee', () async {
        when(mockTaskRepository.findById(task1.id)).thenAnswer((_) async => task1);
        final result = await taskService.getTaskById(task1.id, 'other_user_id');
        expect(result, isNull);
      });
    });

    group('updateTask', () {
      final updatedData = task1.copyWith(title: 'Updated Task 1');
      test('should update task if user is creator', () async {
        when(mockTaskRepository.findById(task1.id)).thenAnswer((_) async => task1);
        when(mockTaskRepository.update(any)).thenAnswer((_) async => updatedData);
        final result = await taskService.updateTask(task1.id, updatedData, testUserId1);
        expect(result.title, 'Updated Task 1');
        verify(mockTaskRepository.update(updatedData)).called(1);
      });
       test('should throw TaskNotFoundException if task not found for update', () {
        when(mockTaskRepository.findById(any)).thenAnswer((_) async => null);
        expect(
          () => taskService.updateTask('non-existent', updatedData, testUserId1),
          throwsA(isA<TaskNotFoundException>()),
        );
      });
      test('should throw ForbiddenException if user is not creator for update', () {
        // task2 is created by testUserId1. testUserId2 (assignee) tries to update.
        when(mockTaskRepository.findById(task2.id)).thenAnswer((_) async => task2);
        expect(
          () => taskService.updateTask(task2.id, task2.copyWith(title:"Update by Assignee"), testUserId2),
          throwsA(isA<ForbiddenException>()),
        );
      });
    });
    
    group('deleteTask', () {
      test('should delete task if user is creator', () async {
        when(mockTaskRepository.findById(task1.id)).thenAnswer((_) async => task1);
        when(mockTaskRepository.delete(task1.id)).thenAnswer((_) async => Future.value());
        await taskService.deleteTask(task1.id, testUserId1);
        verify(mockTaskRepository.delete(task1.id)).called(1);
      });
       test('should throw TaskNotFoundException if task not found for delete', () {
        when(mockTaskRepository.findById(any)).thenAnswer((_) async => null);
        expect(
          () => taskService.deleteTask('non-existent', testUserId1),
          throwsA(isA<TaskNotFoundException>()),
        );
      });
      test('should throw ForbiddenException if user is not creator for delete', () {
        when(mockTaskRepository.findById(task2.id)).thenAnswer((_) async => task2);
        expect(
          () => taskService.deleteTask(task2.id, testUserId2), // User2 (assignee) cannot delete
          throwsA(isA<ForbiddenException>()),
        );
      });
    });

    group('getTasks', () {
      test('should call repository with all provided parameters', () async {
        when(mockTaskRepository.getTasks(
          assigneeId: testUserId1, creatorId: testUserId2, projectId: 'proj-id-1', 
          query: 'search', page: 1, size: 5
        )).thenAnswer((_) async => [task1]);

        final result = await taskService.getTasks(
          assigneeId: testUserId1, creatorId: testUserId2, projectId: 'proj-id-1', 
          query: 'search', page: 1, size: 5
        );
        expect(result, [task1]);
        verify(mockTaskRepository.getTasks(
          assigneeId: testUserId1, creatorId: testUserId2, projectId: 'proj-id-1', 
          query: 'search', page: 1, size: 5
        )).called(1);
      });
    });

    group('assignTask', () {
      test('should assign task and return updated task', () async {
        when(mockTaskRepository.assignTask(task1.id, testUserId2)).thenAnswer((_) async => task1.copyWith(assigneeId: testUserId2));
        final result = await taskService.assignTask(task1.id, testUserId2);
        expect(result.assigneeId, testUserId2);
        verify(mockTaskRepository.assignTask(task1.id, testUserId2)).called(1);
      });
      test('should re-throw TaskNotFoundException from repository', () {
        when(mockTaskRepository.assignTask(any, any)).thenThrow(TaskNotFoundException(id: 'fake-id'));
        expect(
          () => taskService.assignTask('fake-id', testUserId2),
          throwsA(isA<TaskNotFoundException>()),
        );
      });
       test('should re-throw UserNotFoundException from repository', () {
        when(mockTaskRepository.assignTask(any, any)).thenThrow(UserNotFoundException(id: 'fake-user'));
        expect(
          () => taskService.assignTask(task1.id, 'fake-user'),
          throwsA(isA<UserNotFoundException>()),
        );
      });
    });
    
    group('changeTaskStatus', () {
      test('should change task status and return updated task', () async {
        final newStatus = shared_models.TaskStatus.done;
        when(mockTaskRepository.changeTaskStatus(task1.id, newStatus))
            .thenAnswer((_) async => task1.copyWith(status: newStatus));
        
        final result = await taskService.changeTaskStatus(task1.id, newStatus);
        expect(result.status, newStatus);
        verify(mockTaskRepository.changeTaskStatus(task1.id, newStatus)).called(1);
      });
       test('should re-throw TaskNotFoundException from repository for changeStatus', () {
        when(mockTaskRepository.changeTaskStatus(any, any)).thenThrow(TaskNotFoundException(id: 'fake-id'));
        expect(
          () => taskService.changeTaskStatus('fake-id', shared_models.TaskStatus.done),
          throwsA(isA<TaskNotFoundException>()),
        );
      });
    });

  });
}
